// A 1x4-battleship game with a 3-ship.

Sort POS
Var p, q -> POS
Name p0/0, p1/0, p2/0, p3/0, p4/0, p5/0 -> POS
Fun n/1, s/1 -> POS

KB:  n(p1)=p0
KB:  n(p2)=p1
KB:  n(p3)=p2
KB:  n(p4)=p3
KB:  n(p5)=p4

// KB: ~n(p1)=p4
// KB: ~s(p4)=p3

KB: n(s(p))=p
KB: s(n(p))=p
// KB: ~n(p)=p
// KB: ~s(p)=p

// KB: s(p0)=p1
// KB: s(p1)=p2
// KB: s(p2)=p3
// KB: s(p3)=p4
// KB: s(p4)=p5

Sort SHIP
Var x, y -> SHIP
Name three/0 -> SHIP
Fun head/1 -> POS
Fun body/1 -> POS
Fun tail/1 -> POS

Sort BOOL
Name T/0 -> BOOL
Fun water/1 -> BOOL
Fun fired/1 -> BOOL

KB: s(head(three))=body(three)
KB: n(body(three))=head(three)
KB: s(body(three))=tail(three)
KB: n(tail(three))=body(three)

KB: ~water(head(three))=T
KB: ~water(body(three))=T
KB: ~water(tail(three))=T

KB: water(n(head(three)))=T
KB: water(s(tail(three)))=T

KB: p=p1 v p=p2 v p=p3 v p=p4 v water(p)=T
// We don't need the following in the KB. If we do have it, however,
// split level 1 suffices for the assertions below.
// KB: head(three)=p v body(three)=p v tail(three)=p v water(p)=T
Assert: K<2> (head(three)=p v body(three)=p v tail(three)=p v water(p)=T)

Call: bs_init(p1, p2, p3, p4)
Call: bs_print()

Call: bs_fire(p1)
Call: bs_fire(p3)
Call: bs_print()
Assert: K<1> ~water(p1)=T
Assert: K<1> ~water(p3)=T
Assert: K<2>  head(three)=p1
Assert: K<2>  body(three)=p2
Assert: K<2>  tail(three)=p3
Refute: K<2> (body(three)=p2 ^ body(three)/=p2)
Assert: K<1>  water(p0)=T
Assert: K<1> ~water(p1)=T
Assert: K<2> ~water(p2)=T
Assert: K<1> ~water(p3)=T
Assert: K<2>  water(p4)=T
Assert: K<1>  water(p5)=T

